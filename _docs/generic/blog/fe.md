---
title: 프론트엔드 개발자 로드맵
permalink: fe.html
sidebar: generic
tags: [Front-End]
product: Generic
---
! 매일 공부하며 업데이트 하는 것을 목표로 합니다. ! 

## 로드맵의 목적
이 로드맵의 목적은 전체적인 방향에 대한 아이디어를 제공하고
다음에 무엇을 배워야 할지 혼란스러울 경우와 트렌드에 뒤떨어진 것을 배우지 않도록 안내하는 것입니다.
왜 어떤 도구가 다른 도구보다 적합하다고 생각되는지에 대한 이해를 넓혀 가야 하며
유행에 따른 도구를 기억하는 것이 결코 직업에 가장 적합한 것은 아니라는 것을 기억해야 합니다.

## 초보자를 위한 참고사항
이 로드맵은 아래에 나열된 경로에 대해 학습할 수 있는 모든 내용을 담고 있습니다.
압도당하지 마세요! 시작부터 모든 것을 처음부터 끝까지 다 배울 필요는 없습니다.
초보자들을 위한 버전을 작업하고 있으며 2020년 백엔드 및 데브옵스 로드맵을 완료한 후 출시할 예정입니다.

## 소개
![fe1](https://user-images.githubusercontent.com/71207602/93279410-23a72100-f802-11ea-85bd-ad1897d6c823.png)


## 01. 인터넷

### 01) 인터넷은 어떻게 작동 될까요?

#### 정의

1. 인터넷은 웹의 핵심적인 기술이다.

2. 인터넷의 가장 기본적인 것은, 컴퓨터들이 서로 통신 가능한 거대한 네트워크라는 것이다.

3. 인터넷의 어원

   1. 1973년 TCP/IP를 정립한 빈튼 서프와 로버트 칸이 "네트워크의 네트워크"를 구현하여 **모든 컴퓨터를 하나의 통신망 안에 연결(International Network)**하고자 하는 의도에서 이를 줄여 인터넷(Internet)이라고 처음 명명하였던 것에 어원을 두고 있다.

4. 인터넷의 변화

   1. 단순한 네트워크

      1. 1. 1:1 연결
            1. 두 대의 컴퓨터가 통신이 필요할 때, 우리는 다른 컴퓨터와 물리적으로 (보통 이더넷 케이블, 일반적으로 우리가 말하는 '랜선') 또는 무선으로 (WiFi 나 Bluetooth) 연결되어야 한다. 모든 현대 컴퓨터들은 이러한 연결 중 하나를 이용하여 연결을 지속할 수 있다.
         2. 多:多 연결
            1. 우리는 1:1로 연결하는 방식과 같은 방식으로 원하는만큼 컴퓨터를 연결할 수 있다. 하지만 이렇게 연결할 경우 컴퓨터의 수가 늘어날수록 매우 복잡해진다. 1:1로 연결하는 방식으로 10대의 컴퓨터를 연결한다고 생각해보자.
         3. 라우터 연결
            1. 위 문제를 해결하기 위해 네트워크의 각 컴퓨터는 **라우터(Router)라고하는 특수한 소형 컴퓨터**에 연결된다. 이 라우터는 단 하나의 작업만 있다. 철도역의 신호원처럼 **주어진 컴퓨터에서 보낸 메시지가 올바른 대상 컴퓨터에 도착하는지 확인**하는 것이다. 컴퓨터 B에게 메시지를 보내려면 컴퓨터 A가 메시지를 라우터로 보내야하며, 라우터는 메시지를 컴퓨터 B로 전달하고 메시지가 컴퓨터 C로 전달되지 않도록 해야 한다.

   2. 네트워크 속의 네트워크

      1. 컴퓨터를 라우터에 연결하고, 라우터에서 라우터로 연결함으로써 연결을 무한히 확장할 수 있다.

         

### 02) HTTP는 무엇일까요?

**HTTP(Hyper Text Transfer Protoco)**, **인터넷에서 데이터를 주고받을 수 있는 프로토콜**입니다. 프로토콜은 규칙이라고 생각하시면 됩니다. 이렇게 규칙을 정해두었기 때문에, 모든 프로그램이 이 규칙에 맞춰 개발해서 서로 정보를 교환할 수 있게 된 것이죠.

HTTP를 가장 많이 사용하는 개발자는 단언컨데 웹 개발자일 것입니다. 따라서 웹 개발자라면 HTTP에 대해서 잘 알고 있어야 하지만, 많이들 HTTP를 간과하십니다. 백엔드 개발자는 좀 덜하지만, 프론트엔드 개발자는 HTTP를 모르는 경우가 부지기수입니다. 하지만 프론트엔드 개발자의 역할 중 하나가 서버로 데이터를 전송하는 것이기 때문에, HTTP를 모른다면 역할을 다하고 있다고 말할 수 없습니다. 

### 03) 브라우저의 동작 원리

#### 브라우저 주요기능

브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI에 의해 정해진다. 브라우저는 웹 표준화 기구인 W3C에서 정한 명세에 따라 파일을 해석해서 표시한다.

브라우저의 사용자 인터페이스는 브라우저 마다 서로 닮아 있는데 다음과 같은 요소들이 일반적이다.



#### 브라우저의 구성요소

- URI를 입력할 수 있는 주소 표시 줄

- 이전 버튼과 다음 버튼

- 북마크

- 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼

- 홈 버튼

  

### 04) DNS와 작동 원리

**DNS**란 웹사이트의 주소 이름을 IP Address로 매핑시켜 기억할 수 있는 도메인으로 사이트에 접근할 수 있게 해주는 인터넷의 핵심 요소이다. 다음은 verisign에서 제공하는 How DNS work의 설명 내용이다.

#### How DNS work

1. **쿼리 전송** : 브라우저가 유저로부터 입력받은 도메인 이름을 이용해 쿼리를 날린다. 쿼리는 ISP 나 무선 통신업체가 운영하는 DNS Resolver 서버에 도달하여 도메인네임을 IP로 바꾸기 위해 어떤 DNS 서버에 요청해야 하는지를 질의하게 된다.
2. **루트 서버** : DNS Resolver 가 상호작용하는 첫번째 DNS 서버를 루트 서버라 하며, 루트 서버는 .com 과 같은 최상위 도메인에 대한 DNS 정보를 알고 있다. 이 루트서버는 쿼리를 요청한 지점에서 멀지 않은 도메인으로 전송시켜 준다.
3.  **TLD 서버** : TLD 서버는 최상위 도메인 내에 차상위 도메인에 대한 주소 정보를 저장하는 서버로 쿼리가 TLD 서버에 도착하면 TLD 서버가 도메인 네임에 대한 IP주소를 답변한다.
4.  **DNS** : 서버를 거친 쿼리문이 도메인 네임에 대한 IP 주소를 DNS Resolver 로 전송한다.
5.  **Web site** : DNS Resolver 는 문의한 도메인 네임에 해당하는 IP주소를 브라우저에 알려주고 브라우저는 IP 주소로 접근하여 컨텐츠를 가져온다.

#### DNS 정보를 조회하는 Flow는 다음과 같다.

1. 클라이언트(웹 브라우저)가 DNS 를 조회하는 쿼리를 발생시킨다.

2. 발생한 요청은 Local DNS 서버로 이동한다. 이 때의 요청은 다음과 같은 DNS Resolver 들을 거치게 된다.

   1. 클라이언트에 저장된 로컬 네임 서버 DNS 캐시

   2. Internet Service Provider(ISP) 가 제공하는 네임 서버 DNS 캐시

      캐시에서 값이 있으면 해당 IP 정보를 응답값으로 전달한다.

      **여기서 ISP 가 제공하는 네임서버 DNS 캐시가 의무적으로 존재하지는 않는다. ISP 에 따라 존재하는 경우도 있고 없는 경우도 있다. 없다면 요청은 Local PC 의 설정만 조회해보고 바로 3번 이후로 넘어간다.**

      도메인 정보에 따라서 일반 최상위 도메인(.com, .net, .org ...) 이나 국가 최상위 도메인(.kr, .jp ...) 으로 분류되어 각각에 알맞는 TLD 서버의 정보를 전달받는다.

3. DNS 주소에 대한 쿼리가 Root 서버로 향한다. Root 서버는 .com 과 같은 최상위 도메인에 대한 DNS 정보를 포함한다

4. TLD 서버 정보를 이용해 TLD 서버에서 해당 도메인 주소(tistory.com)에 대한 관리 주체 서버로 연결해준다. 

5. 도메인 주소를 관리하는 DNS 서버에서 해당 도메인 주소에 대한 IP 를 반환해준다.

6. 반환된 IP 가 응답으로 전달되면서 Local DNS 에 캐싱된다.

7. Local DNS 를 통해 클라이언트(웹 브라우저) 는 IP 정보를 얻게되고 해당 서버로 접근하게 된다.

   DNS 를 관리하는 구조는 트리형태로 되어있으며 클라이언트가 트리 형태의 DNS 구조에서 쿼리를 통해 결과값을 받아가는 과정이 재귀적(Recursive)이라 하여, Resolver 를 Resulsive Resolver, Query 를 Recursive Query 등으로 부르기도 한다.



### 05) 도메인 네임은 무엇일까요?

**도메인 네임**(**Domain** name, 문화어: 령역이름)**은** 넓은 의미로는 네트워크상에서 컴퓨터를 식별하는 호스트명을 가리키며, 좁은 의미에서는 **도메인** 레지스트리에게서 등록된 이름을 의미한다. 이를 통틀어서 '웹 주소'라고 (잘못) 부르는 경우도 있다.



### 06) 호스팅은 무엇일까요?

웹 호스팅이란 개인이나 기관이 홈페이지를 운영하려고 할 때 서버 컴퓨터가 없는 사람들을 위해서 홈페이지 공간을 임대로 빌려주는 서비스를 말합니다. 웹 호스팅 서비스를 제공하는 업체는 웹사이트와 관련된 데이터를 서버에 저장하고 임차인의 홈페이지가 인터넷과 연결될 수 있도록 기술력을 제공합니다. 웹 호스팅의 장점으로는 저렴한 가격으로 자신의 홈페이지를 운영할 수 있다는 것과 서버 관리에 대해서 전혀 신경을 쓸 필요가 없다는 것입니다. 후자인 부분은 단점으로도 작용을 할 수가 있는데 서버에 문제가 생겼을 때 홈페이지의 주인이 에러를 건드릴 수 있는게 아니라 업체에서 제어를 해야하기 때문에 단점으로 작용할 수 있습니다.



## 02. HTML

### 정의

**HTML**은 HyperText Markup Language의 약자이다. 웹 페이지는 **HTML** 문서라고도 불리며, **HTML** 태그들로 구성된다.

**HTML**은 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.

**HTML**은 웹 브라우저과 같은 HTML 처리 장치의 행동에 영향을 주는 자바스크립트와 본문과 그 밖의 항목의 외면과 배치를 정의하는 CSS 같은 스크립트를 포함하거나 불러올 수 있다. 



### 전송

**HTML** 문서를 다른 컴퓨터 파일과 같은 방법으로 전송할 수 있다. 하지만 HTML 문서들은 대부분 웹 서버에 의한 HTTP 또는 이메일을 통하여 전송한다.

## 03. CSS

### 정의

**캐스케이딩 스타일 시트**(Cascading Style Sheets, **CSS**)는 마크업 언어가 실제 표시되는 방법을 기술하는 언어로, HTML과 XHTML에 주로 쓰이며, HML에서도 사용할 수 있다. W3C의 표준이며, 레이아웃과 스타일을 정의할 때의 자유도가 높다.



### 문법

**CSS**는 단순한 문법을 가지며, 수많은 영어 키워드를 사용하여 다양한 스타일의 프로퍼티의 이름을 규정한다.

스타일 시트는 규칙의 목록으로 구성된다. 각 규칙이나 규칙 집합은 하나 이상의 셀렉터의 하나의 선언 블록을 이룬다.

**CSS**는 따로 CSS만의 코드가 필요하지 않고, 그대로 HTML 문서에 CSS의 키워드를 넣으면 된다.



## 04. JavaScript

### 정의

**자바스크립트(JavaScript)**는 객제 기반의 스크립트 프로그래밍 언어이다. 이 언어는 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능을 가지고 있다. 또한 **Node.Js**와 같은 런타임 환경과 같이 서버 프로그래밍에도 사용되고 있다.



### 문법

#### 단순 문법

자바스크립의 변수는 **var, let, const** 키워드를 사용하여 정의할 수 있다.



### 프로그래밍 언어

한편 자바스크립트에서 사용되는 기초적인 문접의 개념으로는 **속성과 메소드**를 갖는 **객체(오브젝트)** 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할 수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍 언어의 공통적인 주요 개념이기도 하다.



## 05. 버전 관리(Version Control System)

### 버전 관리는 무엇일까요?

버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 **버전**을 다시 꺼내올 수 있는 시스템이다.



### 버전 관리는 왜 사용해야 할까요?

버전 관리 시스템을 사용하면 개발자 또는 개발 팀이 기본적으로 시간 머신에 액세스 할 수 있다. 프로그램이나 시스템을 빌드하는 데 사용 된 소스 코드, 설정 등이 버전 제어하에 있는 경우 개발자는 시간을 들여 기능 손실을 복구 하고 오류가 발생한 방식을 추적하며 이전 버전의 소프트웨어 사용자를 지원할 수 있다.



### 종류

#### 1. 로컬 VCS

서버 없이 로컬 컴퓨터 내에서 버전을 관리한다. 간단한 데이터베이스만으로도 구현이 가능하므로 단순하고 개인적인 프로젝트에 적합하다. 단, 협업에서 쓰기에는 힘들고, 컴퓨터가 고장나는 등 내부 정보가 통째로 날아가버리면 복구할 방법이 없다.



#### 2. 중앙집중식 VCS

서버에 최종본 한 벌이 있으며, 사용자들은 이 중 수정을 원하는 파일만 로컬에 받아 수정한 수 서버에 올리게 된다.

간단한 방법으로 협업이 가능하고 관리자가 누가 어떤 일을 하고 있는지 알기 쉬운 장점이 있다. 단, 중앙 서버가 다운될 경우 그 동안은 업무가 마비되는 단점이 있다. 그리고 서버의 정보가 날아갈 경우 모든 히스토리가 날아가게 된다. 협업의 규모가 커지면 수정 충돌 문제 등이 발생할 수 있다.



#### 3. 분산 VSC

파일을 저장하는 서버가 있는 것은 동일하지만 수정을 위해 프로젝트 전체를 로컬에 다운 받은 뒤 수정한다.

중앙 서버가 다운되더라도 개별 사용자들은 작업이 가능하고 서버가 날아가도 다운 받은 내용은 남아있기 때문에 가장 안정적이다. 수정시에도 현재 코드는 나 혼자 수정하고 있기 때문에 충돌의 염려 없이 수정할 수 있으며, 최종적으로 서버에 올릴 때만 신경써서 Merge 해주면 된다.

대표적으로 **Git**이 있다.

##### 01) Git의 정의

**Git**은 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템이다. 소프트웨어 개발에서 소스 코드 관리에 주로 사용되지만 어떠한 집합의 파일의 변경사항을 지속적으로 추적하기 위해 사용될 수 있다. 기하학적 불변 이론을 바탕으로 설계됐고, 분산 버전 관리 시스템으로서 빠른 수행 속도에 중점을 두고 있는 것이 특징이며 데이터 무결성, 분산, 비선형 워크플로를 지원한다.

##### 02) Git GUI

**Git**은 많은 GUI를 지원하는 것이 특징이다. 현재 소스트리, GitHub Desktop 등의 여러 GUI를 사용할 수 있다.

### 저장소 호스팅 서비스

#### 1. GitHub

##### 1) 정의 

**깃허브**는 분산 버전 관리 툴인 **깃**을 사용하는 프로젝트를 지원하는 웹호스팅 서비스이다. 루비 온 레일스로 작성되었다. GitHub는 영리적인 서비스와 오픈소르를 위한 무상 서비스를 모두 제공한다. 2009년의 Git 사용자 조사에 따르면 GitHub는 가장 인기있는 Git 호스팅 사이트이다. 또한 2011년의 조사에서는 가장 인기있는 오픈 소스 코드 저장소로 꼽혔다.

##### 2. Gitlab

##### 3. Bitbucket



## 06. 웹 보안 지식

## 07. 패키지 매니저
### 정의

컴퓨터 운영체제를 위해 일정한 방식으로 컴퓨터 프로그램의 설치, 업그레이드, 구성, 제거 과정을 자동화하는 소프트웨어 도구들의 모임이다. 

아카이브 파일로 된 소프트웨어 배포판과 데이터인 패키지를 다룬다. 패키지에는 소프트웨어의 이름, 목적에 관한 설명, 버전 번호, 벤더, 체크섬, 소프트웨어의 정상 수행에 필요한 의존성 목록과 같은 메타데이터가 포함된다. 설치 시에 메타데이터는 로컬 패키지 데이터베이스에 저장된다. 패키지 관리자들은 일반적으로 소프트웨어 불일치, 존재하지 않은 필수 항목을 방지하기 위해 소프트웨어 의존성과 버전 정보의 데이터베이스를 유지보수하는 것이 보통이다. 이들은 소프트웨어 저장소, 바이너리 저장소 관리자, 앱 스토어와 밀접하게 동작한다.

### 종류

#### npm

##### 정의

**npm**(노트 패키지 매니저)은 자바스크립트 프로그래밍 언어를 위한 패키지 관리자이다. 자바스크립트 런타임 환경 Node.js의 기본 패키지 관리자이다. 명령 줄 클라이언트(npm), 그리고 공개 패키지와 지불 방식의 개인 패키지의 온라인 데이터베이스(npm 레지스트리)로 이루어져 있다. 이 레지스트리는 클라이언트를 통해 접근되며 사용 가능한 패키지들은 npm 웹 사이트를 통해 찾아보고 검색할 수 있다. 패키지 관리자와 레지스트리는 npm사에 의해 관리된다.

#### yarn

facebook에서 만든 자바스크립트 패키지 매니저, 기존에 존재하는 npm과 동일한 기능을 수행한다.

yarn은 npm보다 고속, 보안, 신뢰성이 좋고 또한 오프라인 모드, 결정적, 네트워크 성능, 동일 패키지, 네트워크 복구, 플랫 모드가 있다.



## 08. CSS 구조 & CSS 전처리기

### CSS 구조

1. 코드의 재사용성을 높이자
2. 쉽게 유지보수 하자
3. 확장 가능하게 하자
4. 클래스명 만으로도 무슨 의미인지 예측 가능하도록 하자

#### BEM

\- **Block(전체를 감싸고 있는 블록요소)__element(내부요소)--modifier(기능)**

\- 클래스명은 구체적이고, 명료하며 HTML 안에서도 읽기 쉬어야 하고, 클래스 명이 무엇을 나타내는지 분명하게 전달 되어야 한다. 

\- 클래스명은 각 html 태그에 오직 클래스명을 하나만 사용해야 한다. 

\- 클래스만을 활용하여 구조화하는 방법이다. 

\- 반복되는 클래스를 만들거나 똑같은 스타일을 반복해서는 안된다. 

\- .header__navigation‐‐secondary과 같은 class를 사용한다

##### Block

\- Block는 문단 전체제 적용된 Element 또는 Element를 담고 있는 컨테이너를 말한다.

##### Element

\- Element는 Block 안에서 특정 기능을 수행하는 컴포넌트이다. Element는 상황에 따라 달라진다. 
\- 각 Element는 두 개의 밑줄표시로 연결하여 Block 다음에 작성한다.

\- Block 이름이나 Element 이름이 길 경우 -(하이픈)으로 연결한다.(강제성은 없음, 프로젝트의 규칙을 적용하면 됨)

##### Modifier

\- Modifier은 Block 또는 Element의 속성이다. 

\- 이 속성은 Block 또는 Element의 의관이나 상태를 변화시킨다.

\- Class명은 "-"를 추가하여 Modifier 추가

\- class명이 길다?

- BEM의 Class명은 구체적이고 명로하여 HTML 안에서도 읽기 쉬워야 한다.
- Class명이 무엇을 나타내는지 분명하게 전달돼야 한다.



### CSS 전처리기

#### SASS

##### 정의

SASS는 CSS를 만들어주는 언어로 자바스크립트처럼 특정 속성(ex. color, margin, width ...)의 값(ex. #000 3px, 420px ...)을 변수로 선언하여 필요한 곳에 선언된 변수를 적용할 수도 있고, 반복되는 코드를 한번의 선언으로 여러 곳에서 재사용할 수 있도록 해주는 등의 기능을 가졌다.



## 09. 빌드 도구

### 모듈번들러

#### Webpack

##### 정의

웹팩은 오픈 소스 자바스크립트 모듈 번들러이다. 주로 자바스크립트를 위한 모듈 번들러이지만 호환 플러그인을 포함하는 경우 HTML, CSS, 심지어는 이미지와 같은 프론트엔드 자산들을 변환할 수 있다. 웹팩은 의존성이 있는 모듈을 취하여 해당 모듈을 대표하는 정적 자산들을 생성한다.

웹팩은 의존성을 취한 다음 의존성 그래프를 만듦으로써 웹 개발자들이 웹 애플리케이션 개발 목적을 웨해 모듈 방식의 접근을 사용할 수 있게 도와준다. 명령 줄을 통해서 사용할 수 있으며, "webpack.config.js"이라는 이름의 구성 파일을 사용하여 구성할 수 있다. 이 파일을 사용하면 프로젝트를 위해 로더, 플러그인 등을 정의할 수 있다. (웹팩은 로더를 통해 상당한 확장이 가능하므로 개발자들이 파일을 함께 번들링할 때 수행하기 원하는 사용자 지정 작업을 작성할 수 있다.) creatapp.dev라는 이름의 도구는 이 구성 파일의 생성 과정을 단순하게 만들어 준다.

웹팩 설치에는 Node.js가 요구된다.


## 10. 프레임워크 선택

## 11. 현대의 CSS

## 12. 웹 컴포넌트

## 13. CSS 프레임워크

## 14. 앱을 테스트 하세요

## 15. 타입 검사

## 16. Progressive Web Apps

## 17. 서버 사이드 렌더링(SSR)

## 18. GraphQL

## 19. 정적 사이트 생성기

## 20. 모바일 어플리케이션

## 21. 데스크탑 어플리케이션

## 22. 웹 어셈블리(Web Assembly)